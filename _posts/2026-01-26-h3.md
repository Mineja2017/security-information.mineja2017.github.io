---
title: h3 Hello Lab
published: true
---

# Summary

## Install Debian on VirtualBox
*   **Download & Setup:** Download the Debian Live ISO from it's website (amd64, xfce recommended) and create a new VirtualBox VM using "Expert Mode" (Name, Type: Linux, Version: Debian 64-bit, 4GB+ RAM, 60GB+ dynamically allocated disk).
*   **Installation:** Run the "Install Debian" program from the live desktop. Select English language and your local keyboard layout.
*   **Partitioning:** Choose the option to erase the disk. Encryption is not recommended for this specific virtual machine exercise (but very critical for real hardware).
*   **User Configuration:** Create a user with a full name, a username, a computer name, and a strong password. Disable auto-login.
*   **Guest Additions:** After the installation you need to install VirtualBox Guest Additions.
*   **Important:** Disble the unattended installation option in the VirtualBox installation and select Debian 64 bits option.

## Command Line Basics Revisited
*   **Navigation:** Use `pwd` to print the working directory, `ls` to list files, and `cd` to change directories (e.g., `cd ..` to go up).
*   **File Operations:**
    *   View files with `less`. (I prefer `cat`)
    *   Edit files with `nano`.
    *   Create folders with `mkdir`.
    *   Move/Rename with `mv` and copy with `cp -r`.
    *   Delete files with `rm`.
*   **Remote Access:** Use `ssh user@host` to log into remote machines and `scp -r local_path user@host:remote_path` to copy files securely.
*   **Package Management:** Install software using `sudo apt-get update` followed by `sudo apt-get install <package>`.

# Task a

After disabling the network (You can do this from the VirtualBox menu), we test to ping the google servers, this is the output:
![ping](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h3/ping.png)

# Task b

With the network dissabled to ensure that we dont scan things that we shouldn't. We do a nmap of our own machine to see what ports are open:
![nmap](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h3/nmap1.png)

# Task c

After installing a daemon, (ssh on this example) we test the open ports again to see the output:
![nmap](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h3/nmap2.png)

# Task d

## Bandit 0
Level 0 of bandit is solved by simply logging in as the bandit0 user with the password given. This is the command I used:
```bash
ssh bandit0@bandit.labs.overthewire.org -p 2220
```
## Bandit 1
When you have logged as bandit0 there is a file that contains the password for bandit1. This is the command I used:
```bash
ls
```
with this we can sea a readme file, so we use:
```bash
cat readme
```
This gives us the password for bandit1.

## Bandit 2
This time the file is called "-" as advised in the instructions. If we use:
```bash
cat -
```
We will get an error because the "-" is being used as a flag, so we use:
```bash
cat ./-
```
Here the ./ is used to specify the current directory, so the system knows we are not using a flag.

## Bandit 3
For this level we need to figure out how to read a file with whitespace in the name. The command I used is:
```bash
cat ./--spaces\ in\ this\ filename--
```
Here the \ is used to escape the whitespace.

## Bandit 4
This time we need to read a file that is hidden. We acces the folder inhere by using:
```bash
cd inhere/
```
And then we use:
```bash
ls -la
```
To see the all the files, including the hidden ones. This is a little tip. Most shell interpreters have an alias for that command. In this case is:
```bash
ll
```
Once we know the name of the hidden file we can use:
```bash
cat ...Hiding-From-You
```
# Extra

I did some extra exercises as I have a more advanced knowledge of Linux. I will add them here:
## Bandit 5
For this level we need to find the redable files in the current directory. The command I used is:
```bash
find . -type f -exec file {} \; | grep ASCII
```
* . --> Specifies the directory to search in. In this case the current directory.
* -type f --> Specifies the type of file to search for. In this case regular files.
* -exec file {} \; --> Executes the file command on each file found. The {} is a placeholder for the file name and the \; is used to end the command.
* | grep ASCII --> Redirects the output of the previous command to the grep command, which filters the output to only show files that are ASCII text.

This gives the filename of the file we were looking for.
```bash
cat <filename_given_by_previous_command>
```

## Bandit 6
Here we need to search for file that match this conditions:
1. Human-readable
2. 1033 bytes in size
3. Not executable

The command I used is:
```bash
find . -type f -size 1033c -exec file {} \; | grep "ASCII"
```
Is the same command as before, but with the size condition added. With the c option we can specify the size in bytes.

This gives the filename of the file we were looking for.
```bash
cat <filename_given_by_previous_command>
```
## Bandit 7
This is the same exercise as before but in the whole system and with other conditions:
1. Owned by user bandit7
2. Owned by group bandit6
3. 33 bytes in size

The command I used is:
```bash
find / -user bandit7 -group bandit6 -size 33c -exec file {} \; 2> /dev/null | grep "ASCII"
```
* 2> /dev/null --> Redirects the error output to /dev/null, which is a special file that discards all data written to it. This is used to hide error messages from the output. In this case error are given beacuse I dont have permission to access some files.
* options `-group` and `-user` are used to specify the group and user of the file.

## Bandit 8
Here the password is hidden inside a file. Next to the word "millionth". We can use grep:
```bash
grep -E millionth data.txt
```
