---
title: h5 Uryyb, Greb!
published: true
---

# Summary

## € Schneier 2015: Applied Cryptography
### 1. Core Terminology and Cryptosystems
This sub-chapter talks about the basic vocabulary of cryptography. The fundamental goal of cryptography is to secure the communication between a sender (Alice) and a receiver (Bob) in the presence of an eavesdropper (Eve). Some key pieces are:

- **Plaintext (M or P)**: The original message.
- **Ciphertext (C)**: The encrypted message.
- **Encryption (E)**: The function that turns plaintext into ciphertext.
- **Decryption (D)**: The function that turns ciphertext into plaintext.

If you like to view from the mathematical perspective here is the definition of a cryptosystem:
$$D(E(M)) = M$$

### 2. Security Objectives
Not only wanting to provide confidientiallity modern cryptography also provides:

- **Integrity**: Ensuring that the message has not been altered in transit.
- **Authentication**: Verifying the identity of the sender.
- **Non-repudiation**: Preventing the sender from denying that they sent the message.

### 3. Algorithms and Keys

We have two types of algorithms:

- **Restricted algorithms**: The security relies on the secrecy of the algorithm. In modern days this is not a good idea, security should rely on the secrecy of the key.
- **Key-based algorithms**: The security relies on the secrecy of the key rather than the algorithm.
  
The definition of this last algorithm is:
$$E_k(M) = C$$
$$D_k(C) = M$$

And inside of the key algorithm we have two types:
- **Symmetric key algorithms**: The same key is used for encryption and decryption.
- **Asymmetric key algorithms**: Different keys are used for encryption and decryption.

### 4. Cryptanalysis
Is the science of breaking ciphertexts without having the key. The attemp to do so is called attack, the difficulty is measured by complexity.

Common attack types are:
- **Ciphertext-only attacks**: The attacker has access to the ciphertext but not the plaintext.
- **Known-plaintext attacks**: The attacker has access to both the ciphertext and the plaintext. (usually used to break the key)
- **Chosen-plaintext attacks**: The attacker has access to the ciphertext of chosen plaintexts.
- **Rubber-hose attacks**: Using torture, blackmail, etc. to get the key.
There is actually a very funny meme about this attack type:
![Rubber-hose attack](https://external-preview.redd.it/EFOZJSuMNXq9SY4VSpmMuynkwbkru-QLoemWAsRU7vg.jpg?auto=webp&s=c2f583956ccb81fac10439d868f7c5cba1567290)

### 5. Historical Cyphers
- **Stenography**: Hiding messages in plain sight.
- **Substitution cyphers**: Replacing characters with others
    - **Monoalphabetic**: Simple replacement (ROT for example). These are easily broken by frequency analysis
    - **Polyalphabetic**: Using multiple keys/alphabets to encrypt specific positions (Vigenère cipher, for example)
- **Transposition cyphers**: Reordering characters

### 6. Special Cyphers
#### Simple XOR
XOR is a logical opration that follows the truth table:
$$
\begin{array}{c|c|c}
A & B & A \oplus B \\
\hline
0 & 0 & 0 \\
0 & 1 & 1 \\
1 & 0 & 1 \\
1 & 1 & 0 \\
\end{array}
$$
Using this scheme we can define a cypher called One-Time pad (OTP):

#### OTP
Is a perfect security cypher. BUT and big BUT if you follow teh rules:
- The key must be as long as the message
- The key must be a good pseudorandom number (computers can't generate true random numbers)
- The key must be used only once -> This is the most important thing.

The math behid this is simple:
$$P_n \oplus K_n = C_n$$
$$C_n \oplus K_n = P_n$$

The problem with this is the key management and distribution as it has to be new every time.

### 7. Modern Outlook
This chapter talks about how modern cryptography is based computational infeasibility (making the cost of breaking the cypher too high) it breafly introduces the concept of:
- **DES**: Most popular symetric cypher (at the time of writing the book)
- **RSA**: Most popular public-key cypher
- **DSA**: Used for digital signatures

## Karvinen 2023: PGP - Send Encrypted and Signed Message - gpg
The article explains how to use gpg command line tool to send encrypted and signed messages.

### 1. Installation
Install gpg and other useful tools:
```bash
sudo apt install gpg micro psmisc
```
### 2. Generate Key Pair
Each user has to generate their own key pair. 

```bash
gpg --gen-key
```
You wil be asked some info as name, email, etc. 

```bash
gpg --fingerprint
```
Impotant to verify the identity of the key owner.

### 3. Exchanging and Trusting Keys
The users must exchange their public keys to send messages.
For exporting the public key:
```bash
gpg --export --armor --output <name>.pub
```
The --armor option is used to make the output human readable.

To import a public key:
```bash
gpg --import <name>.pub
```

To sign/trust the key we use:
```bash
gpg --sign-key <fingerprint>
```
### 4. Sending Encrypted and Signed Messages

```bash
gpg --encrypt --recipient <fingerprint> --sign --output <name>.pgp --armor <message>.txt
```
- --encrypt: Encrypt the message
- --recipient: Specify the recipient (uses the public key)
- --sign: Sign the message
- --output: Specify the output file
- --armor: Make the output human readable

### 5. Receiving Encrypted and Signed Messages
```bash
gpg --decrypt <name>.pgp
```
This will decrypt the message and show it on the screen, It also shows the status of the signature of the message.

# a. Install OpenSSH server
On our machine we install openssh server (I already had it installed):
```bash
sudo apt install openssh-server
```
![install](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/install_ssh.png)

Now we start the server:
```bash
sudo systemctl start ssh
```
![start](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/start_ssh.png)

Now we can connect using the localhost IP address:
```bash
ssh <username>@localhost
```
After the TOFU screen appears and we type de password we are in:
![connect](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/connect_ssh.png)

# b. Automate the connection using public/private keys
The first thing we need to do is generate the public and private keys as a client using this command:
```bash
ssh-keygen -t ed25519 -C "<email>"
```
We use ed25519 as it is a modern and secure algorithm (Elliptic Curve Cryptography, a really not fun topic to study as really hard math are involved).
The -C option is used to add a comment to the key, usually the email of the user.

The prompt will ask us where to save the key, and If we want to add a passphrase. I recommend adding a passphrase beacuse if not anyone can access your server with your key.

![keygen](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/keygen.png)

Now we have to copy the public key to the server:
```bash
ssh-copy-id -i ~/.ssh/<keyname>.pub <username>@<server_ip>
```

![copy_key](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/copy_key.png)

Now we can connect using the file we created:

```bash
ssh -i ~/.ssh/<keyname> <username>@<server_ip>
```

![connect_key](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/connect_key.png)

Note that the passphrase is asked every time we connect, to avoid this we can use ssh-agent.
This is a tool that stores your private key in volatile memory when first booting the PC (and after you enter the passphrase). And it's stored until you reboot the PC. We need to edit the ssh-config file to add our key:
```bash
nano ~/.ssh/config
```
We add this line:
```bash
Host <hostname>
    AddKeysToAgent yes
    IdentityFile ~/.ssh/<keyname>
```
You will need to log in and out for the changes to take effect. You can do this by typing:
```bash
kill -9 -1
```
This will kill all the processes running on your machine, including the terminal. So be careful.

Now you can see that the passphrase is not asked every time we connect:
![automate](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/automate.png)

We can also set an alias to connect to the server and that way we don't to enter the full command every time for example my alias will be ssh_local:
```bash
alias ssh_local="ssh -i ~/.ssh/<keyname> <username>@<server_ip>"
```
# c. Password Manager
For the password manager we will use Keepass. It's the one I used before changing to ProtonPass. The task ask for an offline password manager. Keepass is a free and open-source password manager that is available for multiple platforms. It is a good choice for those who want a password manager that is not dependent on any cloud service.

To install it we just need to download it from the official website [here](https://keepass.info/download.html)

When first opening the app we are greeted with a blank page. You need to created a new Databse in the button provided, choose a location to save it and create a master password. This password is the key to your database, so it must be strong and memorable.

![keepass_1](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/keepass_1.png)

Now we are prompted to enter a name to the database. There are some security options we can configure here, but for now we will just use the default ones.

Once this is done the databse is created (we have some test entries that we can ignore)and we have to add our passwords. We can add them manually or import them from a CSV file. I will add one manually as an example:

![keepass_2](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/keepass_2.png)

We can add the password we like but you have a password generator and some pre-made templates for password creation. Once the password is created we can double click on it to copy it to the clipboard. It will be automatically deleted after a few seconds.

Now you are set, you have a password manager that is not dependent on any cloud service. Remember to lock the database with Ctrl+L every time you close the app. You will need to enter the master password to access it again.

# s. Break "ETAOIN"
This task ypu can choose between two options. I chose to break this cypher text:

```
HDMH'B TH. KWU'YI AWR WSSTOTMJJK M OWQINYIMLIY! MB KWU BII, BTGPJI BUNBHTHUHTWA OTPDIYB OMA NI NYWLIA RTHD SYIEUIAOK MAMJKBTB. BII KWU MH DHHP://HIYWLMYCTAIA.OWG
```

My first approach is as I can see that some characters are not changed, like the apostrophe and the dot. This gave me the idea that could be a ROT cypher with a key different of 13 (The one we saw in class). I used an online tool (I recommend it when talking about criptography) to brute-force ROT key values into de text and see if any output made sense.

![rot](https://raw.githubusercontent.com/Mineja2017/security-information.mineja2017.github.io/refs/heads/main/assets/h5/rot.png)

We see no useful information so let's move on with my next idea. We can see a URL format at the end (: / /) so the previous part should be the word HTTP. Let's try with substitution cipher. In the case of this HTTP part would be:

- H -> D
- T -> H
- P -> P
  
If we continue with other pattern words we can see the starting `HDMH'B`. If we substitute what we have so far we get `TH_T'_` This can only be `THAT'S` so we continue to add letters to our solution. We can also deduce that the last part of the URL is `COM` because we have 3 letters.
The table that I finally managed to build is this:

| Cipher | Plain |
| :----: | :---: |
|   A    |   N   |
|   B    |   S   |
|   C    |   V   |
|   D    |   H   |
|   E    |   Q   |
|   G    |   M   |
|   H    |   T   |
|   I    |   E   |
|   J    |   L   |
|   K    |   Y   |
|   L    |   K   |
|   M    |   A   |
|   N    |   B   |
|   O    |   C   |
|   P    |   P   |
|   Q    |   D   |
|   R    |   W   |
|   S    |   F   |
|   T    |   I   |
|   U    |   U   |
|   W    |   O   |
|   Y    |   R   |

The final decrypted text is:

```
THAT'S IT. YOU'RE NOW OFFICIALLY A CODEBREAKER! AS YOU SEE, SIMPLE SUBSTITUTION CIPHERS CAN BE BROKEN WITH FREQUENCY ANALYSIS. SEE YOU AT HTTP://TEROKARVINEN.COM
```
I created a pyhton script to automate the process:

```python
def decipher_message(ciphertext):
    cipher_known = "ABCDEGHIJKLMNOPQRSTUWY"
    plain_known  = "NSVHQMTELYKABCPDWFIUOR"
    
    translation_table = str.maketrans(cipher_known, plain_known)
    
    return ciphertext.translate(translation_table)

encrypted_text = "HDMH'B TH. KWU'YI AWR WSSTOTMJJK M OWQINYIMLIY! MB KWU BII, BTGPJI BUNBHTHUHTWA OTPDIYB OMA NI NYWLIA RTHD SYIEUIAOK MAMJKBTB. BII KWU MH DHHP://HIYWLMYCTAIA.OWG"

print("Texto cifrado:", encrypted_text)
print("-" * 50)
print("Texto descifrado:", decipher_message(encrypted_text))
```